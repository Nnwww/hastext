{-# LANGUAGE StrictData #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE ViewPatterns #-}

module WordEmbedding.FastText.Dict where

import           WordEmbedding.FastText.Args

import           Control.Monad.Primitive (PrimMonad, PrimState)
import           Control.Monad.ST
import           Control.Monad.Trans.Resource

import           Data.Char                    as C
import           Data.Word
import           Data.Maybe
import qualified Data.ByteString              as BS
import qualified Data.Vector                  as V
import qualified Data.Vector.Mutable          as VM
import qualified Data.Vector.Unboxed          as VU
import qualified Data.Vector.Unboxed.Mutable  as VUM
import qualified Data.Vector.Generic.Mutable  as VGM
import qualified Data.Text                    as T
import qualified Data.Store                   as S
import qualified Data.Hashable                as H
import           Data.Conduit
import qualified Data.Conduit.Combinators     as CC
import           TH.Derive (Deriving, derive)

type WordId    = Maybe Word32
type Vec a     = V.Vector a
type MVec s a  = VM.MVector s a
type UVec a    = VU.Vec a
type UMVec s a = VUM.MVec s a
type TrnsMV prim v a = prim (v (PrimState prim) a)

data Entry = Entry
  { word     :: String
  , count    :: Word64
  , etype    :: EntryType
  , subwords :: Vec WordId
  }

data EntryType = EWord | ELabel

data Dict s = Dict
  { entries  :: MVec s Entry
  , size     :: Word32
  , nwords   :: Word32
  , nlabels  :: Word32
  , ntokens  :: Word64
  }

maxVocabSize = 30000000 :: Int
maxLineSize  =     1024 :: Int

eos = "</s>" :: T.Text
bow =    "<" :: T.Text
eow =    ">" :: T.Text

$($(derive [d|
    instance Deriving (S.Store Entry)
    |]))

$($(derive [d|
    instance Deriving (S.Store EntryType)
    |]))

$($(derive [d|
    instance Deriving (S.Store (Dict s))
    |]))

singleton :: Args -> Dict
singleton args' = Dict
  { entries   = V.empty
  , size      = 0
  , nwords    = 0
  , nlabels   = 0
  , ntokens   = 0
  }

saveDict :: FilePath -> Dict s -> IO ()
saveDict savePath dict = BS.writeFile savePath $ S.encode dict

loadDict :: FilePath -> IO (Dict s)
loadDict readPath = S.decodeIO =<< BS.readFile readPath

initDiscards :: Dict -> Double -> Vec Entry -> Vec Double
initDiscards dict tsub entries = undefined

initNGrams :: Word32 -> V.Vector Entry -> V.Vector WordId
initNGrams size entries = undefined

wordsFromFile :: (MonadResource m, PrimMonad p, VGM.MVector v a)
              => (TrnsMV p v a -> T.Text -> TrnsMV p v a)
              -> TrnsMV p v a
              -> FilePath
              -> ConduitM i T.Text m (TrnsMV p v a)
wordsFromFile modifier init readPath = CC.sourceFile readPath
  .| CC.decodeUtf8
  .| CC.splitOnUnboundedE C.isSpace
  .| CC.foldl modifier init

initFromFile :: Args -> FilePath -> (Dict, MVec s WordId, MVec s Double)
initFromFile args readPath = undefined
  where
    --word2Id   = VM.replicate maxVocabSize Nothing :: TrnsSTV s WordId
    --pDiscards = VUM.replicate maxVocabSize 0      :: TrnsUSTV s Double

hash :: T.Text -> Word32 -> Word32
hashMod  str = fromIntegral $ H.hash str

  
find :: MVec s WordId -> MVec s Entry -> T.Text -> Word32
find w = go $ hash w
  where
    go h = case 
